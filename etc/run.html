<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
     html, body, iframe {
       height: 100%;
       width: 100%;
       margin: 0;
       display: block;
     }
    </style>
    <script type="module">
     class CDP {
       id = 0
       commands = {}
       handlers = {}

       constructor(url) {
         this.ws = new WebSocket(url);
         this.ws.onmessage = ({data}) => {
           const json = JSON.parse(data)
           if (this.commands[json.id]) this.commands[json.id](json);
           else this.handlers[json.method]?.(json.params);
         };
         this.ws.onerror = (err) => { throw err };
         this.ready = new Promise((resolve) => { this.ws.onopen = resolve });
       }

       call(method, params) {
         const id = this.id++, err = new Error()
         return new Promise((resolve, reject) => {
           this.commands[id] = ({result, error}) => {
             delete this.commands[id];
             if (error) reject(Object.assign(err, {message: `${error.code}: ${error.message}`}));
             else resolve(result);
           };
           this.ws.send(JSON.stringify({method, id, params}));
         });
       }

       async waitFor(expression, afterExpression = "() => {}") {
         const {result, exceptionDetails} = await this.call("Runtime.evaluate", {
           awaitPromise: true,
           expression: `
           (async () => {
             while (true) {
               const result = ${expression};
               if (result) {
                 await (${afterExpression})(result);
                 return result;
               }
               await new Promise(r => setTimeout(r, 100));
             }
           })()`,
         });
         if (exceptionDetails) throw new Error(formatExceptionDetails(exceptionDetails));
         return result;
       }

       on(event, f) {
         this.handlers[event] = f;
       }
     }

     class Headless {
       targets = []

       constructor(url) {
         this.server = new WebSocket(url);
         this.server.call = (msg) => this.server.send(JSON.stringify(msg));
         this.server.onopen = () => this.server.call({method: "connect"});
         this.server.onerror = (err) => { throw err };
         this.server.onmessage = ({data}) => {
           const params = JSON.parse(data);
           this[params.method](params);
         };
         this.ready = new Promise((resolve) => { this.resolve = resolve; });
       }

       connect({url}) {
         this.browser = new CDP(url);
         this.browser.ready.then(this.resolve);
       }

       async open({path, isRun}) {
         const url = new URL(path, location).href,
               key = isRun ? path : location.pathname;
         await this.ready;
         const {targetId} = await this.browser.call("Target.createTarget", {url: "about:blank"});
         const page = new CDP(`${new URL(this.browser.ws.url).origin}/devtools/page/${targetId}`);
         await page.ready;
         await page.call("Runtime.enable");
         page.on("Runtime.consoleAPICalled", ({type: method, args}) => {
           this.server.call({key, method, args: args.map(formatConsoleArg)});
         });
         page.on("Runtime.exceptionThrown", ({exceptionDetails}) => {
           this.server.call({key, method: "exception", args: [formatExceptionDetails(exceptionDetails)]});
         });
         await page.call("Page.navigate", {url});
         this.targets.push({url, targetId, page});
         return page;
       }

       async close({path, isRun}) {
         const url = new URL(path, location).href,
               key = isRun ? path : location.pathname;
         const {targetId} = this.targets.find(t => t.url == url);
         this.targets = this.targets.filter(t => t.path !== path);
         this.server.call({key, method: "close"});
         await this.browser.call("Target.closeTarget", {targetId});
       }
     }

     function formatConsoleArg({type: t, subtype, value, description, preview}) {
       if (["string", "number", "boolean", "undefined"].includes(t) || subtype === "null") {
         return value;
       } else if (t === "function" || subtype === "regexp") {
         return description;
       } else if (subtype === "array") {
         return `[${preview.properties.map(p => p.value).join(", ")}]`;
       } else {
         return `{${preview.properties.map(p => `${p.name}: ${p.value}`).join(", ")}}`;
       }
     }

     function formatExceptionDetails(exceptionDetails) {
       const {exception: {description}, url, lineNumber, columnNumber} = exceptionDetails;
       return `${description}\n    at ${url}:${lineNumber}:${columnNumber}`
     }

     window.headless = new Headless(`ws://${location.host}${location.pathname}`);
     window.CDP = CDP;

     window.isHeadless = navigator.webdriver;
     window.close = (code = 0) => isHeadless ? console.clear(code) : console.log("exit:", code);
     window.openIframe = (src) => {
       return new Promise((resolve, reject) => {
         const iframe = document.createElement("iframe");
         const onerror = reject;
         const onload = () => resolve(iframe);
         document.body.appendChild(Object.assign(iframe, {onload, onerror, src}));
       });
     };
    </script>
  </head>
</html>
